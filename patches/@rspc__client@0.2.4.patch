diff --git a/dist/index.cjs b/dist/index.cjs
index e4d1420ca26b527f5b7847dbf882cbe01c25b281..65b60c9bacd595168c72940fe4d6ee57ba7481ca 100644
--- a/dist/index.cjs
+++ b/dist/index.cjs
@@ -219,9 +219,10 @@ var Client = (_class2 = class {
           );
         }
       };
+      const inputVal = keyAndInput[1];
       this.transport.doRequest("subscription", keyAndInput[0], [
         subscriptionId,
-        keyAndInput[1]
+        inputVal instanceof Array && inputVal.length == 0 ? null : inputVal
       ]);
       if (opts.onStarted) opts.onStarted();
       _optionalChain([this, 'access', _19 => _19.subscriptionMap, 'optionalAccess', _20 => _20.set, 'call', _21 => _21(subscriptionId, opts.onData)]);
diff --git a/dist/index.cjs.map b/dist/index.cjs.map
index ce6301e60361f8db1ddd634617b453be95a30931..d87dd28b308ab7e5fdd4e221b529ddae28b17667 100644
--- a/dist/index.cjs.map
+++ b/dist/index.cjs.map
@@ -1 +1 @@
-{"version":3,"sources":["../src/transport.ts","../src/client.ts","../src/error.ts"],"names":["resolve","promise"],"mappings":"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","sourcesContent":["// TODO: Redo this entire system when links are introduced\n// TODO: Make this file work off Typescript types which are exported from Rust to ensure internal type-safety!\nimport { OperationType, RSPCError } from \".\";\n\n// TODO\nexport interface Transport {\n  clientSubscriptionCallback?: (id: string, key: string, value: any) => void;\n\n  doRequest(operation: OperationType, key: string, input: any): Promise<any>;\n}\n\n// TODO\nexport class FetchTransport implements Transport {\n  private url: string;\n  clientSubscriptionCallback?: (id: string, key: string, value: any) => void;\n  private fetch: typeof globalThis.fetch;\n\n  constructor(url: string, fetch?: typeof globalThis.fetch) {\n    this.url = url;\n    this.fetch = fetch || globalThis.fetch.bind(globalThis);\n  }\n\n  async doRequest(\n    operation: OperationType,\n    key: string,\n    input: any\n  ): Promise<any> {\n    if (operation === \"subscription\" || operation === \"subscriptionStop\") {\n      throw new Error(\n        `Subscribing to '${key}' failed as the HTTP transport does not support subscriptions! Maybe try using the websocket transport?`\n      );\n    }\n\n    let method = \"GET\";\n    let body = undefined as any;\n    let headers = new Headers();\n\n    const params = new URLSearchParams();\n    if (operation === \"query\") {\n      if (input !== undefined) {\n        params.append(\"input\", JSON.stringify(input));\n      }\n    } else if (operation === \"mutation\") {\n      method = \"POST\";\n      body = JSON.stringify(input || {});\n      headers.set(\"Content-Type\", \"application/json\");\n    }\n    const paramsStr = params.toString();\n    const resp = await this.fetch(\n      `${this.url}/${key}${paramsStr.length > 0 ? `?${paramsStr}` : \"\"}`,\n      {\n        method,\n        body,\n        headers,\n      }\n    );\n\n    const respBody = await resp.json();\n    const { type, data } = respBody.result;\n    if (type === \"error\") {\n      const { code, message } = data;\n      throw new RSPCError(code, message);\n    }\n    return data;\n  }\n}\n\nexport const randomId = () => Math.random().toString(36).slice(2);\n\nconst timeouts = [1000, 2000, 5000, 10000]; // In milliseconds\n\nexport class WebsocketTransport implements Transport {\n  private url: string;\n  private ws: WebSocket;\n  private requestMap = new Map<\n    string,\n    {\n      op: unknown;\n      cb: (data: any) => void;\n    }\n  >();\n  clientSubscriptionCallback?: (id: string, value: any) => void;\n\n  constructor(url: string) {\n    this.url = url;\n    this.ws = new WebSocket(url);\n    this.attachEventListeners();\n  }\n\n  attachEventListeners() {\n    // Resume all in-progress tasks\n    for (const [_, item] of this.requestMap) {\n      this.ws.send(JSON.stringify(item.op));\n    }\n\n    this.ws.addEventListener(\"message\", (event) => {\n      const { id, result } = JSON.parse(event.data);\n      if (result.type === \"event\") {\n        if (this.clientSubscriptionCallback)\n          this.clientSubscriptionCallback(id, result.data);\n      } else if (result.type === \"response\") {\n        if (this.requestMap.has(id)) {\n          this.requestMap\n            .get(id)\n            ?.cb({ type: \"response\", result: result.data });\n          this.requestMap.delete(id);\n        }\n      } else if (result.type === \"error\") {\n        const { message, code } = result.data;\n        if (this.requestMap.has(id)) {\n          this.requestMap.get(id)?.cb({ type: \"error\", message, code });\n          this.requestMap.delete(id);\n        }\n      } else {\n        console.error(`Received event of unknown type '${result.type}'`);\n      }\n    });\n\n    this.ws.addEventListener(\"close\", (event) => {\n      this.reconnect();\n    });\n  }\n\n  async reconnect(timeoutIndex = 0) {\n    let timeout =\n      (timeouts[timeoutIndex] ?? timeouts[timeouts.length - 1]) +\n      (Math.floor(Math.random() * 5000 /* 5 Seconds */) + 1);\n\n    setTimeout(() => {\n      let ws = new WebSocket(this.url);\n      new Promise(function (resolve, reject) {\n        ws.addEventListener(\"open\", () => resolve(null));\n        ws.addEventListener(\"close\", reject);\n      })\n        .then(() => {\n          this.ws = ws;\n          this.attachEventListeners();\n        })\n        .catch((err) => this.reconnect(timeoutIndex++));\n    }, timeout);\n  }\n\n  async doRequest(\n    operation: OperationType,\n    key: string,\n    input: any,\n    opts?: {\n      id?: string;\n    }\n  ): Promise<any> {\n    if (this.ws.readyState == 0) {\n      let resolve: () => void;\n      const promise = new Promise((res) => {\n        resolve = () => res(undefined);\n      });\n      // @ts-ignore\n      this.ws.addEventListener(\"open\", resolve);\n      await promise;\n    }\n\n    const id = randomId();\n    let resolve: (data: any) => void;\n    const promise = new Promise((res) => {\n      resolve = res;\n    });\n\n    this.requestMap.set(id, {\n      op: {\n        id,\n        method: operation,\n        params: {\n          path: key,\n          input,\n        },\n      },\n      // @ts-ignore\n      cb: resolve,\n    });\n\n    this.ws.send(\n      JSON.stringify({\n        id,\n        method: operation,\n        params: {\n          path: key,\n          input,\n        },\n      })\n    );\n\n    const body = (await promise) as any;\n    if (body.type === \"error\") {\n      const { code, message } = body;\n      throw new RSPCError(code, message);\n    } else if (body.type === \"response\") {\n      return body.result;\n    } else {\n      throw new Error(\n        `RSPC Websocket doRequest received invalid body type '${body?.type}'`\n      );\n    }\n  }\n}\n\n// TODO\nexport class NoOpTransport implements Transport {\n  constructor() {}\n\n  async doRequest(\n    operation: OperationType,\n    key: string,\n    input: string\n  ): Promise<any> {\n    return new Promise(() => {});\n  }\n}\n","// TODO: Redo this entire system when links are introduced\nimport {\n\tRSPCError,\n\tProceduresLike,\n\tinferQueryResult,\n\tProceduresDef,\n\tinferMutationResult,\n\tinferProcedures,\n\tinferSubscriptionResult,\n\t_inferInfiniteQueryProcedureHandlerInput,\n\t_inferProcedureHandlerInput,\n} from \".\";\nimport { randomId, Transport } from \"./transport\";\n\n// TODO\nexport interface SubscriptionOptions<TOutput> {\n\tonStarted?: () => void;\n\tonData: (data: TOutput) => void;\n\tonError?: (err: RSPCError) => void;\n}\n\n// TODO\nexport interface ClientArgs {\n\ttransport: Transport;\n\tonError?: (err: RSPCError) => void | Promise<void>;\n}\n\n// TODO\nexport function createClient<TProcedures extends ProceduresLike>(\n\targs: ClientArgs,\n): Client<inferProcedures<TProcedures>> {\n\treturn new Client(args);\n}\n\n// TODO\nexport class Client<TProcedures extends ProceduresDef> {\n\tpublic _rspc_def: ProceduresDef = undefined!;\n\tprivate transport: Transport;\n\tprivate subscriptionMap = new Map<string, (data: any) => void>();\n\tprivate onError?: (err: RSPCError) => void | Promise<void>;\n\n\tconstructor(args: ClientArgs) {\n\t\tthis.transport = args.transport;\n\t\tthis.transport.clientSubscriptionCallback = (id, value) => {\n\t\t\tconst func = this.subscriptionMap?.get(id);\n\t\t\tif (func !== undefined) func(value);\n\t\t};\n\t\tthis.subscriptionMap = new Map();\n\t\tthis.onError = args.onError;\n\t}\n\n\tasync query<K extends TProcedures[\"queries\"][\"key\"] & string>(\n\t\tkeyAndInput: [\n\t\t\tkey: K,\n\t\t\t...input: _inferProcedureHandlerInput<TProcedures, \"queries\", K>,\n\t\t],\n\t): Promise<inferQueryResult<TProcedures, K>> {\n\t\ttry {\n\t\t\treturn await this.transport.doRequest(\n\t\t\t\t\"query\",\n\t\t\t\tkeyAndInput[0],\n\t\t\t\tkeyAndInput[1],\n\t\t\t);\n\t\t} catch (err) {\n\t\t\tif (this.onError) {\n\t\t\t\tthis.onError(err as RSPCError);\n\t\t\t}\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\tasync mutation<K extends TProcedures[\"mutations\"][\"key\"] & string>(\n\t\tkeyAndInput: [\n\t\t\tkey: K,\n\t\t\t...input: _inferProcedureHandlerInput<TProcedures, \"mutations\", K>,\n\t\t],\n\t): Promise<inferMutationResult<TProcedures, K>> {\n\t\ttry {\n\t\t\treturn await this.transport.doRequest(\n\t\t\t\t\"mutation\",\n\t\t\t\tkeyAndInput[0],\n\t\t\t\tkeyAndInput[1],\n\t\t\t);\n\t\t} catch (err) {\n\t\t\tif (this.onError) {\n\t\t\t\tthis.onError(err as RSPCError);\n\t\t\t}\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\t// TODO: Redesign this, i'm sure it probably has race conditions but it works for now\n\taddSubscription<\n\t\tK extends TProcedures[\"subscriptions\"][\"key\"] & string,\n\t\tTData = inferSubscriptionResult<TProcedures, K>,\n\t>(\n\t\tkeyAndInput: [\n\t\t\tkey: K,\n\t\t\t...input: _inferProcedureHandlerInput<TProcedures, \"subscriptions\", K>,\n\t\t],\n\t\topts: SubscriptionOptions<TData>,\n\t): () => void {\n\t\ttry {\n\t\t\tconst subscriptionId = randomId();\n\t\t\tlet unsubscribed = false;\n\n\t\t\tconst cleanup = () => {\n\t\t\t\tthis.subscriptionMap?.delete(subscriptionId);\n\t\t\t\tif (subscriptionId) {\n\t\t\t\t\tthis.transport.doRequest(\n\t\t\t\t\t\t\"subscriptionStop\",\n\t\t\t\t\t\tundefined!,\n\t\t\t\t\t\tsubscriptionId,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis.transport.doRequest(\"subscription\", keyAndInput[0], [\n\t\t\t\tsubscriptionId,\n\t\t\t\tkeyAndInput[1],\n\t\t\t]);\n\n\t\t\tif (opts.onStarted) opts.onStarted();\n\t\t\tthis.subscriptionMap?.set(subscriptionId, opts.onData);\n\n\t\t\treturn () => {\n\t\t\t\tunsubscribed = true;\n\t\t\t\tcleanup();\n\t\t\t};\n\t\t} catch (err) {\n\t\t\tif (this.onError) {\n\t\t\t\tthis.onError(err as RSPCError);\n\t\t\t}\n\n\t\t\treturn () => {};\n\t\t}\n\t}\n}\n","export class RSPCError {\n  code: number;\n  message: string;\n\n  constructor(code: number, message: string) {\n    this.code = code;\n    this.message = message;\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"sources":["d:\\NodeJS\\rspc\\packages\\client\\dist\\index.cjs"],"names":[],"mappings":"AAAA;AACA,IAAI,eAAe,EAAE,MAAM;AAC3B,EAAE;AACF,EAAE;AACF,EAAE;AACF,EAAE,WAAW,CAAC,GAAG,EAAE,KAAK,EAAE;AAC1B,IAAI,IAAI,CAAC,IAAI,EAAE,GAAG;AAClB,IAAI,IAAI,CAAC,MAAM,EAAE,MAAM,GAAG,UAAU,CAAC,KAAK,CAAC,IAAI,CAAC,UAAU,CAAC;AAC3D,EAAE;AACF,EAAE,MAAM,SAAS,CAAC,SAAS,EAAE,GAAG,EAAE,KAAK,EAAE;AACzC,IAAI,GAAG,CAAC,UAAU,IAAI,eAAe,GAAG,UAAU,IAAI,kBAAkB,EAAE;AAC1E,MAAM,MAAM,IAAI,KAAK;AACrB,QAAQ,CAAC,gBAAgB,EAAE,GAAG,CAAC,uGAAuG;AACtI,MAAM,CAAC;AACP,IAAI;AACJ,IAAI,IAAI,OAAO,EAAE,KAAK;AACtB,IAAI,IAAI,KAAK,EAAE,KAAK,CAAC;AACrB,IAAI,IAAI,QAAQ,EAAE,IAAI,OAAO,CAAC,CAAC;AAC/B,IAAI,MAAM,OAAO,EAAE,IAAI,eAAe,CAAC,CAAC;AACxC,IAAI,GAAG,CAAC,UAAU,IAAI,OAAO,EAAE;AAC/B,MAAM,GAAG,CAAC,MAAM,IAAI,KAAK,CAAC,EAAE;AAC5B,QAAQ,MAAM,CAAC,MAAM,CAAC,OAAO,EAAE,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;AACrD,MAAM;AACN,IAAI,EAAE,KAAK,GAAG,CAAC,UAAU,IAAI,UAAU,EAAE;AACzC,MAAM,OAAO,EAAE,MAAM;AACrB,MAAM,KAAK,EAAE,IAAI,CAAC,SAAS,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;AACxC,MAAM,OAAO,CAAC,GAAG,CAAC,cAAc,EAAE,kBAAkB,CAAC;AACrD,IAAI;AACJ,IAAI,MAAM,UAAU,EAAE,MAAM,CAAC,QAAQ,CAAC,CAAC;AACvC,IAAI,MAAM,KAAK,EAAE,MAAM,IAAI,CAAC,KAAK;AACjC,MAAM,CAAC,EAAA;AACA,MAAA;AACA,QAAA;AACA,QAAA;AACA,QAAA;AACA,MAAA;AACA,IAAA;AACA,IAAA;AACA,IAAA;AACA,IAAA;AACA,MAAA;AACA,MAAA;AACA,IAAA;AACA,IAAA;AACA,EAAA;AACA;AACA;AACA;AACA;AACA,EAAA;AACA,EAAA;AACA,iBAAA;AACA,EAAA;AACA,EAAA;AACA,IAAA;AACA,IAAA;AACA,IAAA;AACA,EAAA;AACA,EAAA;AACA,IAAA;AACA,MAAA;AACA,IAAA;AACA,IAAA;AACA,MAAA;AACA,MAAA;AACA,QAAA;AACA,UAAA;AACA,MAAA;AACA,QAAA;AACA,0BAAA;AACA,UAAA;AACA,QAAA;AACA,MAAA;AACA,QAAA;AACA,QAAA;AACA,0BAAA;AACA,UAAA;AACA,QAAA;AACA,MAAA;AACA,QAAA;AACA,MAAA;AACA,IAAA;AACA,IAAA;AACA,MAAA;AACA,IAAA;AACA,EAAA;AACA,EAAA;AACA,IAAA;AACA,MAAA;AACA;AACA,IAAA;AACA,IAAA;AACA,MAAA;AACA,MAAA;AACA,QAAA;AACA,QAAA;AACA,MAAA;AACA,QAAA;AACA,QAAA;AACA,MAAA;AACA,IAAA;AACA,EAAA;AACA,EAAA;AACA,IAAA;AACA,MAAA;AACA,MAAA;AACA,QAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,IAAA;AACA,IAAA;AACA,IAAA;AACA,IAAA;AACA,MAAA;AACA,IAAA;AACA,IAAA;AACA,MAAA;AACA,QAAA;AACA,QAAA;AACA,QAAA;AACA,UAAA;AACA,UAAA;AACA,QAAA;AACA,MAAA;AACA;AACA,MAAA;AACA,IAAA;AACA,IAAA;AACA,MAAA;AACA,QAAA;AACA,QAAA;AACA,QAAA;AACA,UAAA;AACA,UAAA;AACA,QAAA;AACA,MAAA;AACA,IAAA;AACA,IAAA;AACA,IAAA;AACA,MAAA;AACA,MAAA;AACA,IAAA;AACA,MAAA;AACA,IAAA;AACA,MAAA;AACA,QAAA;AACA,MAAA;AACA,IAAA;AACA,EAAA;AACA;AACA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,IAAA;AACA,IAAA;AACA,EAAA;AACA;AACA;AACA;AACA;AACA,EAAA;AACA;AACA;AACA,kBAAA;AACA,EAAA;AACA,kBAAA;AACA,EAAA;AACA,EAAA;AACA,IAAA;AACA,IAAA;AACA,MAAA;AACA,MAAA;AACA,IAAA;AACA,IAAA;AACA,IAAA;AACA,EAAA;AACA,EAAA;AACA,IAAA;AACA,MAAA;AACA,QAAA;AACA,QAAA;AACA,QAAA;AACA,MAAA;AACA,IAAA;AACA,MAAA;AACA,QAAA;AACA,MAAA;AACA,MAAA;AACA,IAAA;AACA,EAAA;AACA,EAAA;AACA,IAAA;AACA,MAAA;AACA,QAAA;AACA,QAAA;AACA,QAAA;AACA,MAAA;AACA,IAAA;AACA,MAAA;AACA,QAAA;AACA,MAAA;AACA,MAAA;AACA,IAAA;AACA,EAAA;AACA;AACA,EAAA;AACA,IAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,wBAAA;AACA,QAAA;AACA,UAAA;AACA,YAAA;AACA,YAAA;AACA,YAAA;AACA,UAAA;AACA,QAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,QAAA;AACA,QAAA;AACA,MAAA;AACA,MAAA;AACA,sBAAA;AACA,MAAA;AACA,QAAA;AACA,QAAA;AACA,MAAA;AACA,IAAA;AACA,MAAA;AACA,QAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,IAAA;AACA,EAAA;AACA;AACA;AACA;AACA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,IAAA;AACA,IAAA;AACA,EAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"D:\\NodeJS\\rspc\\packages\\client\\dist\\index.cjs","sourcesContent":[null]}
\ No newline at end of file
diff --git a/dist/index.js b/dist/index.js
index 8b58046b58d865a0730567190657f1d49c4f557b..ac923aba73a50c8d7edb8921e54ddbb3c7e0a5f4 100644
--- a/dist/index.js
+++ b/dist/index.js
@@ -219,9 +219,10 @@ var Client = class {
           );
         }
       };
+      const inputVal = keyAndInput[1];
       this.transport.doRequest("subscription", keyAndInput[0], [
         subscriptionId,
-        keyAndInput[1]
+        inputVal instanceof Array && inputVal.length == 0 ? null : inputVal
       ]);
       if (opts.onStarted) opts.onStarted();
       this.subscriptionMap?.set(subscriptionId, opts.onData);
diff --git a/dist/index.js.map b/dist/index.js.map
index 3d0706815dbad2fbd2e8c9b7f3d6ffa68dbbd7d3..e78e9968963ec5ba28794007728fb959ea13ad40 100644
--- a/dist/index.js.map
+++ b/dist/index.js.map
@@ -1 +1 @@
-{"version":3,"sources":["../src/transport.ts","../src/client.ts","../src/error.ts"],"sourcesContent":["// TODO: Redo this entire system when links are introduced\n// TODO: Make this file work off Typescript types which are exported from Rust to ensure internal type-safety!\nimport { OperationType, RSPCError } from \".\";\n\n// TODO\nexport interface Transport {\n  clientSubscriptionCallback?: (id: string, key: string, value: any) => void;\n\n  doRequest(operation: OperationType, key: string, input: any): Promise<any>;\n}\n\n// TODO\nexport class FetchTransport implements Transport {\n  private url: string;\n  clientSubscriptionCallback?: (id: string, key: string, value: any) => void;\n  private fetch: typeof globalThis.fetch;\n\n  constructor(url: string, fetch?: typeof globalThis.fetch) {\n    this.url = url;\n    this.fetch = fetch || globalThis.fetch.bind(globalThis);\n  }\n\n  async doRequest(\n    operation: OperationType,\n    key: string,\n    input: any\n  ): Promise<any> {\n    if (operation === \"subscription\" || operation === \"subscriptionStop\") {\n      throw new Error(\n        `Subscribing to '${key}' failed as the HTTP transport does not support subscriptions! Maybe try using the websocket transport?`\n      );\n    }\n\n    let method = \"GET\";\n    let body = undefined as any;\n    let headers = new Headers();\n\n    const params = new URLSearchParams();\n    if (operation === \"query\") {\n      if (input !== undefined) {\n        params.append(\"input\", JSON.stringify(input));\n      }\n    } else if (operation === \"mutation\") {\n      method = \"POST\";\n      body = JSON.stringify(input || {});\n      headers.set(\"Content-Type\", \"application/json\");\n    }\n    const paramsStr = params.toString();\n    const resp = await this.fetch(\n      `${this.url}/${key}${paramsStr.length > 0 ? `?${paramsStr}` : \"\"}`,\n      {\n        method,\n        body,\n        headers,\n      }\n    );\n\n    const respBody = await resp.json();\n    const { type, data } = respBody.result;\n    if (type === \"error\") {\n      const { code, message } = data;\n      throw new RSPCError(code, message);\n    }\n    return data;\n  }\n}\n\nexport const randomId = () => Math.random().toString(36).slice(2);\n\nconst timeouts = [1000, 2000, 5000, 10000]; // In milliseconds\n\nexport class WebsocketTransport implements Transport {\n  private url: string;\n  private ws: WebSocket;\n  private requestMap = new Map<\n    string,\n    {\n      op: unknown;\n      cb: (data: any) => void;\n    }\n  >();\n  clientSubscriptionCallback?: (id: string, value: any) => void;\n\n  constructor(url: string) {\n    this.url = url;\n    this.ws = new WebSocket(url);\n    this.attachEventListeners();\n  }\n\n  attachEventListeners() {\n    // Resume all in-progress tasks\n    for (const [_, item] of this.requestMap) {\n      this.ws.send(JSON.stringify(item.op));\n    }\n\n    this.ws.addEventListener(\"message\", (event) => {\n      const { id, result } = JSON.parse(event.data);\n      if (result.type === \"event\") {\n        if (this.clientSubscriptionCallback)\n          this.clientSubscriptionCallback(id, result.data);\n      } else if (result.type === \"response\") {\n        if (this.requestMap.has(id)) {\n          this.requestMap\n            .get(id)\n            ?.cb({ type: \"response\", result: result.data });\n          this.requestMap.delete(id);\n        }\n      } else if (result.type === \"error\") {\n        const { message, code } = result.data;\n        if (this.requestMap.has(id)) {\n          this.requestMap.get(id)?.cb({ type: \"error\", message, code });\n          this.requestMap.delete(id);\n        }\n      } else {\n        console.error(`Received event of unknown type '${result.type}'`);\n      }\n    });\n\n    this.ws.addEventListener(\"close\", (event) => {\n      this.reconnect();\n    });\n  }\n\n  async reconnect(timeoutIndex = 0) {\n    let timeout =\n      (timeouts[timeoutIndex] ?? timeouts[timeouts.length - 1]) +\n      (Math.floor(Math.random() * 5000 /* 5 Seconds */) + 1);\n\n    setTimeout(() => {\n      let ws = new WebSocket(this.url);\n      new Promise(function (resolve, reject) {\n        ws.addEventListener(\"open\", () => resolve(null));\n        ws.addEventListener(\"close\", reject);\n      })\n        .then(() => {\n          this.ws = ws;\n          this.attachEventListeners();\n        })\n        .catch((err) => this.reconnect(timeoutIndex++));\n    }, timeout);\n  }\n\n  async doRequest(\n    operation: OperationType,\n    key: string,\n    input: any,\n    opts?: {\n      id?: string;\n    }\n  ): Promise<any> {\n    if (this.ws.readyState == 0) {\n      let resolve: () => void;\n      const promise = new Promise((res) => {\n        resolve = () => res(undefined);\n      });\n      // @ts-ignore\n      this.ws.addEventListener(\"open\", resolve);\n      await promise;\n    }\n\n    const id = randomId();\n    let resolve: (data: any) => void;\n    const promise = new Promise((res) => {\n      resolve = res;\n    });\n\n    this.requestMap.set(id, {\n      op: {\n        id,\n        method: operation,\n        params: {\n          path: key,\n          input,\n        },\n      },\n      // @ts-ignore\n      cb: resolve,\n    });\n\n    this.ws.send(\n      JSON.stringify({\n        id,\n        method: operation,\n        params: {\n          path: key,\n          input,\n        },\n      })\n    );\n\n    const body = (await promise) as any;\n    if (body.type === \"error\") {\n      const { code, message } = body;\n      throw new RSPCError(code, message);\n    } else if (body.type === \"response\") {\n      return body.result;\n    } else {\n      throw new Error(\n        `RSPC Websocket doRequest received invalid body type '${body?.type}'`\n      );\n    }\n  }\n}\n\n// TODO\nexport class NoOpTransport implements Transport {\n  constructor() {}\n\n  async doRequest(\n    operation: OperationType,\n    key: string,\n    input: string\n  ): Promise<any> {\n    return new Promise(() => {});\n  }\n}\n","// TODO: Redo this entire system when links are introduced\nimport {\n\tRSPCError,\n\tProceduresLike,\n\tinferQueryResult,\n\tProceduresDef,\n\tinferMutationResult,\n\tinferProcedures,\n\tinferSubscriptionResult,\n\t_inferInfiniteQueryProcedureHandlerInput,\n\t_inferProcedureHandlerInput,\n} from \".\";\nimport { randomId, Transport } from \"./transport\";\n\n// TODO\nexport interface SubscriptionOptions<TOutput> {\n\tonStarted?: () => void;\n\tonData: (data: TOutput) => void;\n\tonError?: (err: RSPCError) => void;\n}\n\n// TODO\nexport interface ClientArgs {\n\ttransport: Transport;\n\tonError?: (err: RSPCError) => void | Promise<void>;\n}\n\n// TODO\nexport function createClient<TProcedures extends ProceduresLike>(\n\targs: ClientArgs,\n): Client<inferProcedures<TProcedures>> {\n\treturn new Client(args);\n}\n\n// TODO\nexport class Client<TProcedures extends ProceduresDef> {\n\tpublic _rspc_def: ProceduresDef = undefined!;\n\tprivate transport: Transport;\n\tprivate subscriptionMap = new Map<string, (data: any) => void>();\n\tprivate onError?: (err: RSPCError) => void | Promise<void>;\n\n\tconstructor(args: ClientArgs) {\n\t\tthis.transport = args.transport;\n\t\tthis.transport.clientSubscriptionCallback = (id, value) => {\n\t\t\tconst func = this.subscriptionMap?.get(id);\n\t\t\tif (func !== undefined) func(value);\n\t\t};\n\t\tthis.subscriptionMap = new Map();\n\t\tthis.onError = args.onError;\n\t}\n\n\tasync query<K extends TProcedures[\"queries\"][\"key\"] & string>(\n\t\tkeyAndInput: [\n\t\t\tkey: K,\n\t\t\t...input: _inferProcedureHandlerInput<TProcedures, \"queries\", K>,\n\t\t],\n\t): Promise<inferQueryResult<TProcedures, K>> {\n\t\ttry {\n\t\t\treturn await this.transport.doRequest(\n\t\t\t\t\"query\",\n\t\t\t\tkeyAndInput[0],\n\t\t\t\tkeyAndInput[1],\n\t\t\t);\n\t\t} catch (err) {\n\t\t\tif (this.onError) {\n\t\t\t\tthis.onError(err as RSPCError);\n\t\t\t}\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\tasync mutation<K extends TProcedures[\"mutations\"][\"key\"] & string>(\n\t\tkeyAndInput: [\n\t\t\tkey: K,\n\t\t\t...input: _inferProcedureHandlerInput<TProcedures, \"mutations\", K>,\n\t\t],\n\t): Promise<inferMutationResult<TProcedures, K>> {\n\t\ttry {\n\t\t\treturn await this.transport.doRequest(\n\t\t\t\t\"mutation\",\n\t\t\t\tkeyAndInput[0],\n\t\t\t\tkeyAndInput[1],\n\t\t\t);\n\t\t} catch (err) {\n\t\t\tif (this.onError) {\n\t\t\t\tthis.onError(err as RSPCError);\n\t\t\t}\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\t// TODO: Redesign this, i'm sure it probably has race conditions but it works for now\n\taddSubscription<\n\t\tK extends TProcedures[\"subscriptions\"][\"key\"] & string,\n\t\tTData = inferSubscriptionResult<TProcedures, K>,\n\t>(\n\t\tkeyAndInput: [\n\t\t\tkey: K,\n\t\t\t...input: _inferProcedureHandlerInput<TProcedures, \"subscriptions\", K>,\n\t\t],\n\t\topts: SubscriptionOptions<TData>,\n\t): () => void {\n\t\ttry {\n\t\t\tconst subscriptionId = randomId();\n\t\t\tlet unsubscribed = false;\n\n\t\t\tconst cleanup = () => {\n\t\t\t\tthis.subscriptionMap?.delete(subscriptionId);\n\t\t\t\tif (subscriptionId) {\n\t\t\t\t\tthis.transport.doRequest(\n\t\t\t\t\t\t\"subscriptionStop\",\n\t\t\t\t\t\tundefined!,\n\t\t\t\t\t\tsubscriptionId,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis.transport.doRequest(\"subscription\", keyAndInput[0], [\n\t\t\t\tsubscriptionId,\n\t\t\t\tkeyAndInput[1],\n\t\t\t]);\n\n\t\t\tif (opts.onStarted) opts.onStarted();\n\t\t\tthis.subscriptionMap?.set(subscriptionId, opts.onData);\n\n\t\t\treturn () => {\n\t\t\t\tunsubscribed = true;\n\t\t\t\tcleanup();\n\t\t\t};\n\t\t} catch (err) {\n\t\t\tif (this.onError) {\n\t\t\t\tthis.onError(err as RSPCError);\n\t\t\t}\n\n\t\t\treturn () => {};\n\t\t}\n\t}\n}\n","export class RSPCError {\n  code: number;\n  message: string;\n\n  constructor(code: number, message: string) {\n    this.code = code;\n    this.message = message;\n  }\n}\n"],"mappings":"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","names":["resolve","promise"]}
\ No newline at end of file
+{"version":3,"sources":["../src/transport.ts","../src/client.ts","../src/error.ts"],"sourcesContent":["// TODO: Redo this entire system when links are introduced\r\n// TODO: Make this file work off Typescript types which are exported from Rust to ensure internal type-safety!\r\nimport { OperationType, RSPCError } from \".\";\r\n\r\n// TODO\r\nexport interface Transport {\r\n  clientSubscriptionCallback?: (id: string, key: string, value: any) => void;\r\n\r\n  doRequest(operation: OperationType, key: string, input: any): Promise<any>;\r\n}\r\n\r\n// TODO\r\nexport class FetchTransport implements Transport {\r\n  private url: string;\r\n  clientSubscriptionCallback?: (id: string, key: string, value: any) => void;\r\n  private fetch: typeof globalThis.fetch;\r\n\r\n  constructor(url: string, fetch?: typeof globalThis.fetch) {\r\n    this.url = url;\r\n    this.fetch = fetch || globalThis.fetch.bind(globalThis);\r\n  }\r\n\r\n  async doRequest(\r\n    operation: OperationType,\r\n    key: string,\r\n    input: any\r\n  ): Promise<any> {\r\n    if (operation === \"subscription\" || operation === \"subscriptionStop\") {\r\n      throw new Error(\r\n        `Subscribing to '${key}' failed as the HTTP transport does not support subscriptions! Maybe try using the websocket transport?`\r\n      );\r\n    }\r\n\r\n    let method = \"GET\";\r\n    let body = undefined as any;\r\n    let headers = new Headers();\r\n\r\n    const params = new URLSearchParams();\r\n    if (operation === \"query\") {\r\n      if (input !== undefined) {\r\n        params.append(\"input\", JSON.stringify(input));\r\n      }\r\n    } else if (operation === \"mutation\") {\r\n      method = \"POST\";\r\n      body = JSON.stringify(input || {});\r\n      headers.set(\"Content-Type\", \"application/json\");\r\n    }\r\n    const paramsStr = params.toString();\r\n    const resp = await this.fetch(\r\n      `${this.url}/${key}${paramsStr.length > 0 ? `?${paramsStr}` : \"\"}`,\r\n      {\r\n        method,\r\n        body,\r\n        headers,\r\n      }\r\n    );\r\n\r\n    const respBody = await resp.json();\r\n    const { type, data } = respBody.result;\r\n    if (type === \"error\") {\r\n      const { code, message } = data;\r\n      throw new RSPCError(code, message);\r\n    }\r\n    return data;\r\n  }\r\n}\r\n\r\nexport const randomId = () => Math.random().toString(36).slice(2);\r\n\r\nconst timeouts = [1000, 2000, 5000, 10000]; // In milliseconds\r\n\r\nexport class WebsocketTransport implements Transport {\r\n  private url: string;\r\n  private ws: WebSocket;\r\n  private requestMap = new Map<\r\n    string,\r\n    {\r\n      op: unknown;\r\n      cb: (data: any) => void;\r\n    }\r\n  >();\r\n  clientSubscriptionCallback?: (id: string, value: any) => void;\r\n\r\n  constructor(url: string) {\r\n    this.url = url;\r\n    this.ws = new WebSocket(url);\r\n    this.attachEventListeners();\r\n  }\r\n\r\n  attachEventListeners() {\r\n    // Resume all in-progress tasks\r\n    for (const [_, item] of this.requestMap) {\r\n      this.ws.send(JSON.stringify(item.op));\r\n    }\r\n\r\n    this.ws.addEventListener(\"message\", (event) => {\r\n      const { id, result } = JSON.parse(event.data);\r\n      if (result.type === \"event\") {\r\n        if (this.clientSubscriptionCallback)\r\n          this.clientSubscriptionCallback(id, result.data);\r\n      } else if (result.type === \"response\") {\r\n        if (this.requestMap.has(id)) {\r\n          this.requestMap\r\n            .get(id)\r\n            ?.cb({ type: \"response\", result: result.data });\r\n          this.requestMap.delete(id);\r\n        }\r\n      } else if (result.type === \"error\") {\r\n        const { message, code } = result.data;\r\n        if (this.requestMap.has(id)) {\r\n          this.requestMap.get(id)?.cb({ type: \"error\", message, code });\r\n          this.requestMap.delete(id);\r\n        }\r\n      } else {\r\n        console.error(`Received event of unknown type '${result.type}'`);\r\n      }\r\n    });\r\n\r\n    this.ws.addEventListener(\"close\", (event) => {\r\n      this.reconnect();\r\n    });\r\n  }\r\n\r\n  async reconnect(timeoutIndex = 0) {\r\n    let timeout =\r\n      (timeouts[timeoutIndex] ?? timeouts[timeouts.length - 1]) +\r\n      (Math.floor(Math.random() * 5000 /* 5 Seconds */) + 1);\r\n\r\n    setTimeout(() => {\r\n      let ws = new WebSocket(this.url);\r\n      new Promise(function (resolve, reject) {\r\n        ws.addEventListener(\"open\", () => resolve(null));\r\n        ws.addEventListener(\"close\", reject);\r\n      })\r\n        .then(() => {\r\n          this.ws = ws;\r\n          this.attachEventListeners();\r\n        })\r\n        .catch((err) => this.reconnect(timeoutIndex++));\r\n    }, timeout);\r\n  }\r\n\r\n  async doRequest(\r\n    operation: OperationType,\r\n    key: string,\r\n    input: any,\r\n    opts?: {\r\n      id?: string;\r\n    }\r\n  ): Promise<any> {\r\n    if (this.ws.readyState == 0) {\r\n      let resolve: () => void;\r\n      const promise = new Promise((res) => {\r\n        resolve = () => res(undefined);\r\n      });\r\n      // @ts-ignore\r\n      this.ws.addEventListener(\"open\", resolve);\r\n      await promise;\r\n    }\r\n\r\n    const id = randomId();\r\n    let resolve: (data: any) => void;\r\n    const promise = new Promise((res) => {\r\n      resolve = res;\r\n    });\r\n\r\n    this.requestMap.set(id, {\r\n      op: {\r\n        id,\r\n        method: operation,\r\n        params: {\r\n          path: key,\r\n          input,\r\n        },\r\n      },\r\n      // @ts-ignore\r\n      cb: resolve,\r\n    });\r\n\r\n    this.ws.send(\r\n      JSON.stringify({\r\n        id,\r\n        method: operation,\r\n        params: {\r\n          path: key,\r\n          input,\r\n        },\r\n      })\r\n    );\r\n\r\n    const body = (await promise) as any;\r\n    if (body.type === \"error\") {\r\n      const { code, message } = body;\r\n      throw new RSPCError(code, message);\r\n    } else if (body.type === \"response\") {\r\n      return body.result;\r\n    } else {\r\n      throw new Error(\r\n        `RSPC Websocket doRequest received invalid body type '${body?.type}'`\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\n// TODO\r\nexport class NoOpTransport implements Transport {\r\n  constructor() {}\r\n\r\n  async doRequest(\r\n    operation: OperationType,\r\n    key: string,\r\n    input: string\r\n  ): Promise<any> {\r\n    return new Promise(() => {});\r\n  }\r\n}\r\n","// TODO: Redo this entire system when links are introduced\r\nimport {\r\n\tRSPCError,\r\n\tProceduresLike,\r\n\tinferQueryResult,\r\n\tProceduresDef,\r\n\tinferMutationResult,\r\n\tinferProcedures,\r\n\tinferSubscriptionResult,\r\n\t_inferInfiniteQueryProcedureHandlerInput,\r\n\t_inferProcedureHandlerInput,\r\n} from \".\";\r\nimport { randomId, Transport } from \"./transport\";\r\n\r\n// TODO\r\nexport interface SubscriptionOptions<TOutput> {\r\n\tonStarted?: () => void;\r\n\tonData: (data: TOutput) => void;\r\n\tonError?: (err: RSPCError) => void;\r\n}\r\n\r\n// TODO\r\nexport interface ClientArgs {\r\n\ttransport: Transport;\r\n\tonError?: (err: RSPCError) => void | Promise<void>;\r\n}\r\n\r\n// TODO\r\nexport function createClient<TProcedures extends ProceduresLike>(\r\n\targs: ClientArgs,\r\n): Client<inferProcedures<TProcedures>> {\r\n\treturn new Client(args);\r\n}\r\n\r\n// TODO\r\nexport class Client<TProcedures extends ProceduresDef> {\r\n\tpublic _rspc_def: ProceduresDef = undefined!;\r\n\tprivate transport: Transport;\r\n\tprivate subscriptionMap = new Map<string, (data: any) => void>();\r\n\tprivate onError?: (err: RSPCError) => void | Promise<void>;\r\n\r\n\tconstructor(args: ClientArgs) {\r\n\t\tthis.transport = args.transport;\r\n\t\tthis.transport.clientSubscriptionCallback = (id, value) => {\r\n\t\t\tconst func = this.subscriptionMap?.get(id);\r\n\t\t\tif (func !== undefined) func(value);\r\n\t\t};\r\n\t\tthis.subscriptionMap = new Map();\r\n\t\tthis.onError = args.onError;\r\n\t}\r\n\r\n\tasync query<K extends TProcedures[\"queries\"][\"key\"] & string>(\r\n\t\tkeyAndInput: [\r\n\t\t\tkey: K,\r\n\t\t\t...input: _inferProcedureHandlerInput<TProcedures, \"queries\", K>,\r\n\t\t],\r\n\t): Promise<inferQueryResult<TProcedures, K>> {\r\n\t\ttry {\r\n\t\t\treturn await this.transport.doRequest(\r\n\t\t\t\t\"query\",\r\n\t\t\t\tkeyAndInput[0],\r\n\t\t\t\tkeyAndInput[1],\r\n\t\t\t);\r\n\t\t} catch (err) {\r\n\t\t\tif (this.onError) {\r\n\t\t\t\tthis.onError(err as RSPCError);\r\n\t\t\t}\r\n\t\t\tthrow err;\r\n\t\t}\r\n\t}\r\n\r\n\tasync mutation<K extends TProcedures[\"mutations\"][\"key\"] & string>(\r\n\t\tkeyAndInput: [\r\n\t\t\tkey: K,\r\n\t\t\t...input: _inferProcedureHandlerInput<TProcedures, \"mutations\", K>,\r\n\t\t],\r\n\t): Promise<inferMutationResult<TProcedures, K>> {\r\n\t\ttry {\r\n\t\t\treturn await this.transport.doRequest(\r\n\t\t\t\t\"mutation\",\r\n\t\t\t\tkeyAndInput[0],\r\n\t\t\t\tkeyAndInput[1],\r\n\t\t\t);\r\n\t\t} catch (err) {\r\n\t\t\tif (this.onError) {\r\n\t\t\t\tthis.onError(err as RSPCError);\r\n\t\t\t}\r\n\t\t\tthrow err;\r\n\t\t}\r\n\t}\r\n\r\n\t// TODO: Redesign this, i'm sure it probably has race conditions but it works for now\r\n\taddSubscription<\r\n\t\tK extends TProcedures[\"subscriptions\"][\"key\"] & string,\r\n\t\tTData = inferSubscriptionResult<TProcedures, K>,\r\n\t>(\r\n\t\tkeyAndInput: [\r\n\t\t\tkey: K,\r\n\t\t\t...input: _inferProcedureHandlerInput<TProcedures, \"subscriptions\", K>,\r\n\t\t],\r\n\t\topts: SubscriptionOptions<TData>,\r\n\t): () => void {\r\n\t\ttry {\r\n\t\t\tconst subscriptionId = randomId();\r\n\t\t\tlet unsubscribed = false;\r\n\r\n\t\t\tconst cleanup = () => {\r\n\t\t\t\tthis.subscriptionMap?.delete(subscriptionId);\r\n\t\t\t\tif (subscriptionId) {\r\n\t\t\t\t\tthis.transport.doRequest(\r\n\t\t\t\t\t\t\"subscriptionStop\",\r\n\t\t\t\t\t\tundefined!,\r\n\t\t\t\t\t\tsubscriptionId,\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\tconst inputVal = keyAndInput[1]\r\n\t\t\tthis.transport.doRequest(\"subscription\", keyAndInput[0], [\r\n\t\t\t\tsubscriptionId,\r\n\t\t\t\t((inputVal as any) instanceof Array && inputVal.length == 0) ? null : inputVal,\r\n\t\t\t]);\r\n\r\n\t\t\tif (opts.onStarted) opts.onStarted();\r\n\t\t\tthis.subscriptionMap?.set(subscriptionId, opts.onData);\r\n\r\n\t\t\treturn () => {\r\n\t\t\t\tunsubscribed = true;\r\n\t\t\t\tcleanup();\r\n\t\t\t};\r\n\t\t} catch (err) {\r\n\t\t\tif (this.onError) {\r\n\t\t\t\tthis.onError(err as RSPCError);\r\n\t\t\t}\r\n\r\n\t\t\treturn () => {};\r\n\t\t}\r\n\t}\r\n}\r\n","export class RSPCError {\r\n  code: number;\r\n  message: string;\r\n\r\n  constructor(code: number, message: string) {\r\n    this.code = code;\r\n    this.message = message;\r\n  }\r\n}\r\n"],"mappings":"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","names":["resolve","promise"]}
\ No newline at end of file
diff --git a/dist/types/client.d.ts.map b/dist/types/client.d.ts.map
index 1fe7b0d72596477e757d6272b1e15f72d65ddeb8..f2281e4d7db40c13bf5b456d9958464cb7049a29 100644
--- a/dist/types/client.d.ts.map
+++ b/dist/types/client.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"client.d.ts","sourceRoot":"","sources":["../../src/client.ts"],"names":[],"mappings":"AACA,OAAO,EACN,SAAS,EACT,cAAc,EACd,gBAAgB,EAChB,aAAa,EACb,mBAAmB,EACnB,eAAe,EACf,uBAAuB,EAEvB,2BAA2B,EAC3B,MAAM,GAAG,CAAC;AACX,OAAO,EAAY,SAAS,EAAE,MAAM,aAAa,CAAC;AAGlD,MAAM,WAAW,mBAAmB,CAAC,OAAO;IAC3C,SAAS,CAAC,EAAE,MAAM,IAAI,CAAC;IACvB,MAAM,EAAE,CAAC,IAAI,EAAE,OAAO,KAAK,IAAI,CAAC;IAChC,OAAO,CAAC,EAAE,CAAC,GAAG,EAAE,SAAS,KAAK,IAAI,CAAC;CACnC;AAGD,MAAM,WAAW,UAAU;IAC1B,SAAS,EAAE,SAAS,CAAC;IACrB,OAAO,CAAC,EAAE,CAAC,GAAG,EAAE,SAAS,KAAK,IAAI,GAAG,OAAO,CAAC,IAAI,CAAC,CAAC;CACnD;AAGD,wBAAgB,YAAY,CAAC,WAAW,SAAS,cAAc,EAC9D,IAAI,EAAE,UAAU,GACd,MAAM,CAAC,eAAe,CAAC,WAAW,CAAC,CAAC,CAEtC;AAGD,qBAAa,MAAM,CAAC,WAAW,SAAS,aAAa;IAC7C,SAAS,EAAE,aAAa,CAAc;IAC7C,OAAO,CAAC,SAAS,CAAY;IAC7B,OAAO,CAAC,eAAe,CAA0C;IACjE,OAAO,CAAC,OAAO,CAAC,CAA2C;gBAE/C,IAAI,EAAE,UAAU;IAUtB,KAAK,CAAC,CAAC,SAAS,WAAW,CAAC,SAAS,CAAC,CAAC,KAAK,CAAC,GAAG,MAAM,EAC3D,WAAW,EAAE;QACZ,GAAG,EAAE,CAAC;QACN,GAAG,KAAK,EAAE,2BAA2B,CAAC,WAAW,EAAE,SAAS,EAAE,CAAC,CAAC;KAChE,GACC,OAAO,CAAC,gBAAgB,CAAC,WAAW,EAAE,CAAC,CAAC,CAAC;IAetC,QAAQ,CAAC,CAAC,SAAS,WAAW,CAAC,WAAW,CAAC,CAAC,KAAK,CAAC,GAAG,MAAM,EAChE,WAAW,EAAE;QACZ,GAAG,EAAE,CAAC;QACN,GAAG,KAAK,EAAE,2BAA2B,CAAC,WAAW,EAAE,WAAW,EAAE,CAAC,CAAC;KAClE,GACC,OAAO,CAAC,mBAAmB,CAAC,WAAW,EAAE,CAAC,CAAC,CAAC;IAgB/C,eAAe,CACd,CAAC,SAAS,WAAW,CAAC,eAAe,CAAC,CAAC,KAAK,CAAC,GAAG,MAAM,EACtD,KAAK,GAAG,uBAAuB,CAAC,WAAW,EAAE,CAAC,CAAC,EAE/C,WAAW,EAAE;QACZ,GAAG,EAAE,CAAC;QACN,GAAG,KAAK,EAAE,2BAA2B,CAAC,WAAW,EAAE,eAAe,EAAE,CAAC,CAAC;KACtE,EACD,IAAI,EAAE,mBAAmB,CAAC,KAAK,CAAC,GAC9B,MAAM,IAAI;CAoCb"}
\ No newline at end of file
+{"version":3,"file":"client.d.ts","sourceRoot":"","sources":["../../src/client.ts"],"names":[],"mappings":"AACA,OAAO,EACN,SAAS,EACT,cAAc,EACd,gBAAgB,EAChB,aAAa,EACb,mBAAmB,EACnB,eAAe,EACf,uBAAuB,EAEvB,2BAA2B,EAC3B,MAAM,GAAG,CAAC;AACX,OAAO,EAAY,SAAS,EAAE,MAAM,aAAa,CAAC;AAGlD,MAAM,WAAW,mBAAmB,CAAC,OAAO;IAC3C,SAAS,CAAC,EAAE,MAAM,IAAI,CAAC;IACvB,MAAM,EAAE,CAAC,IAAI,EAAE,OAAO,KAAK,IAAI,CAAC;IAChC,OAAO,CAAC,EAAE,CAAC,GAAG,EAAE,SAAS,KAAK,IAAI,CAAC;CACnC;AAGD,MAAM,WAAW,UAAU;IAC1B,SAAS,EAAE,SAAS,CAAC;IACrB,OAAO,CAAC,EAAE,CAAC,GAAG,EAAE,SAAS,KAAK,IAAI,GAAG,OAAO,CAAC,IAAI,CAAC,CAAC;CACnD;AAGD,wBAAgB,YAAY,CAAC,WAAW,SAAS,cAAc,EAC9D,IAAI,EAAE,UAAU,GACd,MAAM,CAAC,eAAe,CAAC,WAAW,CAAC,CAAC,CAEtC;AAGD,qBAAa,MAAM,CAAC,WAAW,SAAS,aAAa;IAC7C,SAAS,EAAE,aAAa,CAAc;IAC7C,OAAO,CAAC,SAAS,CAAY;IAC7B,OAAO,CAAC,eAAe,CAA0C;IACjE,OAAO,CAAC,OAAO,CAAC,CAA2C;gBAE/C,IAAI,EAAE,UAAU;IAUtB,KAAK,CAAC,CAAC,SAAS,WAAW,CAAC,SAAS,CAAC,CAAC,KAAK,CAAC,GAAG,MAAM,EAC3D,WAAW,EAAE;QACZ,GAAG,EAAE,CAAC;QACN,GAAG,KAAK,EAAE,2BAA2B,CAAC,WAAW,EAAE,SAAS,EAAE,CAAC,CAAC;KAChE,GACC,OAAO,CAAC,gBAAgB,CAAC,WAAW,EAAE,CAAC,CAAC,CAAC;IAetC,QAAQ,CAAC,CAAC,SAAS,WAAW,CAAC,WAAW,CAAC,CAAC,KAAK,CAAC,GAAG,MAAM,EAChE,WAAW,EAAE;QACZ,GAAG,EAAE,CAAC;QACN,GAAG,KAAK,EAAE,2BAA2B,CAAC,WAAW,EAAE,WAAW,EAAE,CAAC,CAAC;KAClE,GACC,OAAO,CAAC,mBAAmB,CAAC,WAAW,EAAE,CAAC,CAAC,CAAC;IAgB/C,eAAe,CACd,CAAC,SAAS,WAAW,CAAC,eAAe,CAAC,CAAC,KAAK,CAAC,GAAG,MAAM,EACtD,KAAK,GAAG,uBAAuB,CAAC,WAAW,EAAE,CAAC,CAAC,EAE/C,WAAW,EAAE;QACZ,GAAG,EAAE,CAAC;QACN,GAAG,KAAK,EAAE,2BAA2B,CAAC,WAAW,EAAE,eAAe,EAAE,CAAC,CAAC;KACtE,EACD,IAAI,EAAE,mBAAmB,CAAC,KAAK,CAAC,GAC9B,MAAM,IAAI;CAqCb"}
\ No newline at end of file
